We are given n continuous variables within Ranges [li, ui], and m inequalities. Each 
inequality Iğ‘— is of the form:

Iğ‘—:ğ‘ğ‘—1*ğ‘¥1+â‹¯+ğ‘ğ‘—ğ‘›*ğ‘¥ğ‘›â‰¤ğ‘‘ğ‘—

Given that each  ğ‘¥ğ‘–âˆˆ[lğ‘–,uğ‘–] are the bounds for each variable  ğ‘¥ğ‘– , 
let  ğ—ğ—‰ğ—‰ğ–¾ğ—‹ğ–¡ğ—ˆğ—ğ—‡ğ–½ğ–«ğ–§ğ–²(Iğ‘—) denote the maximum value that the LHS Expression  
ğ‘ğ‘—1ğ‘¥1+â‹¯+ğ‘ğ‘—ğ‘›ğ‘¥ğ‘› takes in the domain  ğ‘¥1âˆˆ[l1,u1],â€¦,ğ‘¥ğ‘›âˆˆ[lğ‘›,uğ‘›].


For each inequality ğ¼ğ‘—:ğ‘ğ‘—1*ğ‘¥1+â‹¯+ğ‘ğ‘—ğ‘›*ğ‘¥ğ‘›â‰¤ğ‘‘ğ‘—, we convert it into the following 
inequality ğ¼Ì‚ ğ‘—: ğ‘ğ‘—1*ğ‘¥1+â‹¯+ğ‘ğ‘—ğ‘›*ğ‘¥ğ‘›â‰¤ğ‘‘ğ‘—*ğ‘¤ğ‘—+ğ‘€ğ‘—*(1âˆ’ğ‘¤ğ‘—) where ğ‘€ğ‘—=ğ—ğ—‰ğ—‰ğ–¾ğ—‹ğ–¡ğ—ˆğ—ğ—‡ğ–½ğ–«ğ–§ğ–²(ğ¼ğ‘—) . 
Prove that ğ¼Ì‚ ğ‘— is the same as ğ¼ğ‘— when ğ‘¤ğ‘—=1 and ğ¼Ì‚ ğ‘— is implied by the other 
constraints when ğ‘¤ğ‘—=0 . In fact, we need to maximize ğ‘¤1+â‹¯+ğ‘¤ğ‘š.

We would like to implement the mixed integer linear programming above using python by completing a function solveForMaximumInequalitySatisfaction with the following 
arguments:

Input #1: "n" the number of variables 

Input #2: "m" the number of inequalities 

Input #3: "c_matrix" which is a list of list of coefficients of the LHS of inequalities,
in a form like this:

c_matrix = 
[
    [c11,...,c1n],
    [c21,...,c2n],
    ...
    [cm1,...,cmn],
]

Please note python indexes starting from 0. 

Input #4: "d_values" which is a list of RHS coefficients, 
in a form like this:
d_values = [ğ‘‘1,â€¦,ğ‘‘ğ‘š] 

Input #5: "bounds" which is a list of pairs  [(I1,u1),â€¦,(Iğ‘›,uğ‘›)] for each variable. 


Your function should return a pair:  (ğ‘˜,[ğ‘¥1,â€¦,ğ‘¥ğ‘›]). In which: 
- ğ‘˜ is the number of inequalities satisfied by your optimal solution
- [ğ‘¥1,â€¦,ğ‘¥ğ‘›]  is a list denoting the values of ğ‘¥1,â€¦,ğ‘¥ğ‘› that satisfy the ğ‘˜ inequalities.

# Here is a useful function to implement the LHS upper bound that we need for the encoding
def lhsUpperBound(c_list, bounds):
    n = len(c_list)
    assert len(bounds) == n 
    upper_bnd = sum([(cj*lj) if cj < 0 else cj*uj for (cj, (lj, uj)) in zip(c_list, bounds) ])
    return upper_bnd

Use Pulp library to implement the solution in python by completing the following function:

def solveForMaximumInequalitySatisfaction(n, m, c_matrix, d_values, bounds):
    # always check pre-conditions: saves so much time later
    assert len(c_matrix) == m
    assert all(len(c_list) == n for c_list in c_matrix)
    assert len(d_values) == m
    assert len(bounds) == n
    assert all (lj <= uj for (lj, uj) in bounds)
    ## TODO: set up and solve the problem for satisfying the maximum number of inequalities
    # your code here








====================================================================================

Now we want create a huristic algorithm, without mixed integer programming, 
that satisfies at least m/2 of constraints.

Generate ğ‘› random numbers ğ‘Ÿ1,â€¦,ğ‘Ÿğ‘› in some range [âˆ’1,1] and simply substitute: 
ğ‘¥1=ğ‘Ÿ1*ğ‘¥,
ğ‘¥2=ğ‘Ÿ2*ğ‘¥,
â€¦,
ğ‘¥ğ‘›=ğ‘Ÿğ‘›*ğ‘¥ 
where ğ‘¥ is a new unknown variable. 

Now, if we partition the inequalities into two subsets: 

Subset #1: All inequalities with a positive coefficient for ğ‘¥, which are:
ğ‘¥â‰¤ğ‘‘ğ‘–1,â€¦,ğ‘¥â‰¤ğ‘‘ğ‘–ğ‘š By setting  ğ‘¥=max(ğ‘‘ğ‘–1,â€¦,ğ‘‘ğ‘–ğ‘š) we can satisfy all 
these inequalities. 

Subset #2: All inequalities with a negative coefficient for ğ‘¥, which are: 
âˆ’ğ‘¥â‰¤ğ‘‘ğ‘—1,â€¦,âˆ’ğ‘¥â‰¤ğ‘‘ğ‘—ğ‘š 

At least one of these partitions must account for  ğ‘š/2 or more constraints.

Using the algorithm for ğ‘›=1 variables, implement an algorithm that 
achieves a factor-2 approximation for inequalities with arbitrary ğ‘›. 
Specifically, given a system of ğ‘š inequalities over ğ‘¥1,â€¦,ğ‘¥ğ‘› , 
provide an algorithm that finds a solution (ğ‘¥1,â€¦,ğ‘¥ğ‘›) that satisfies â‰¥ğ‘š/2 inequalities.


Complete function below to implement the algorithm:

from random import uniform 

def computeApproximateSolution(n, m, c_matrix, d_values):
    assert n >= 1
    assert len(c_matrix) == m
    assert all(len(c_list) == n for c_list in c_matrix)
    assert len(d_values) == m
    r_values = [uniform(-1, 1) for i in range(n)]
    # your code here
