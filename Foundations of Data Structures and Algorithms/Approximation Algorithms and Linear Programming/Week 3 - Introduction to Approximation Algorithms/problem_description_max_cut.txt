we would like to design a greedy mac-cut algorithm in a graph G to partition it into two 
sets of vertices S1 and S2. We define a node  ğ‘£ is imbalanced if it has strictly 
more number of edges to other nodes within its partition than edges crossing the cut.

STEP 1. 
Input a graph as an adjacency list and return a partition where every vertex is balanced, 
as described above.

Initiat list called "cut" as first  ğ‘›/2 nodes to S1 (as true) and remaining to  ğ‘†2 (as False).

Implement a helper function called imbalanced_vertices, and maintain an array 
with the number of edges for each node that are cut and so on.

STEP 2. 
Algorithm must return a cut where all nodes are balanced, in other words:

while there exists an imbalanced node in partition  (ğ‘†1,ğ‘†2): 
    ğ‘£ := findImbalancedNode(ğº,ğ‘†1,ğ‘†2)
 
Flip the current partition that  ğ‘£ is in (i.e, if  ğ‘£âˆˆğ‘†1 then move  ğ‘£ to  ğ‘†2 or vice-versa).

STEP 3.
Return a list of Booleans of size n, wherein for any vertex v, if list[v] = True then 
it belongs to partition S1 otherwise to partition S2.


This is the python function that you will implement the greedy algorithm. 


def find_balanced_cut(n, adj_list): 
    assert n >= 1
    assert len(adj_list) == n
    # Check that the adjacency list makes sense and represents a directed graph
    for (i, neighbors) in enumerate(adj_list):
        assert all( 0 <= j < n for j in neighbors )
        assert i not in neighbors # no self loops allowed
        for j in neighbors: 
            assert i in adj_list[j]
    # just start with an initial cut tthat places first n/2 nodes in S1 and rest in S2.
    cut = [True if i < n/2 else False for i in range(n)]
    


Heer are some extra functions to create the adjacency list and test partitions:

# Make an adjacency list out of a list of edges.
def mk_adjacency_list(n, edge_list):
    adj_list = [set() for i in range(n)]
    for (i,j) in edge_list:
        adj_list[i].add(j)
        adj_list[j].add(i)
    return adj_list

# Test Partition
def test_cut(n, adj_list, cut):
    num_edges_crossing_cut = [0]*n
    for (i, neighbors) in enumerate(adj_list):
        num_edges_crossing_cut[i] = sum([cut[i] != cut[j] for j in neighbors])
        if 2 * num_edges_crossing_cut[i] < len(neighbors):
                assert f'Test Failed: In your cut, vertex {i} has {len(neighbors)} edges incident on it but only {num_edges_crossing_cut[i]} edges cross the cut'
    return 
   

and here is a sample test:

n = 5
edge_list =  [(0,1),(0,2),(0,3),(0,4), (1,2),(1,3),(2,4),(3,4)]
adj_list = mk_adjacency_list(n, edge_list)
print(f'Adjacency list is {adj_list}')
cut = find_balanced_cut(n, adj_list)
test_cut(n, adj_list, cut)
print('Tests Passed (5 points)')